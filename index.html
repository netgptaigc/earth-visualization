<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高级实时活动地球 - Advanced Real-time Active Earth</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #000428, #004e92);
            font-family: 'Arial', sans-serif;
        }
        
        #info {
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 8px rgba(0, 150, 255, 0.7);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
            text-align: center;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            font-size: 14px;
        }
        
        .control-item {
            margin: 5px 0;
        }
        
        input[type="range"] {
            width: 150px;
            vertical-align: middle;
        }
        
        .label {
            display: inline-block;
            width: 120px;
        }
    </style>
</head>
<body>
    <div id="info">高级实时活动地球 - 使用鼠标拖拽旋转，滚轮缩放 | 实时显示当前时间</div>
    <div id="loading">
        <div>正在加载地球...</div>
        <div id="progress">0%</div>
    </div>
    
    <div id="controls">
        <div class="control-item">
            <span class="label">自转速度:</span>
            <input type="range" id="rotationSpeed" min="0" max="0.01" step="0.001" value="0.002">
        </div>
        <div class="control-item">
            <span class="label">云层速度:</span>
            <input type="range" id="cloudSpeed" min="0" max="0.02" step="0.001" value="0.003">
        </div>
        <div class="control-item">
            <span class="label">光照强度:</span>
            <input type="range" id="lightIntensity" min="0" max="2" step="0.1" value="1">
        </div>
        <div class="control-item">
            <span class="label">当前时间:</span>
            <span id="currentTime">--:--:--</span>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // 初始化场景
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制高DPR设备以提高性能
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // 设置相机位置
        camera.position.z = 5;
        
        // 添加光源（模拟太阳光）
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xFFFFFF, 1);
        sunLight.position.set(5, 3, 5);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);
        
        // 添加额外的背光来模拟地球反照
        const backLight = new THREE.DirectionalLight(0x2266AA, 0.2);
        backLight.position.set(-5, -3, -5);
        scene.add(backLight);
        
        // 创建地球
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);
        
        const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
        
        // 加载纹理
        const textureLoader = new THREE.TextureLoader();
        let earthMaterial, earthMesh;
        
        // 地球纹理（日间）
        const earthTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg', 
            () => updateProgress(25, '纹理加载完成'));
        const earthBumpMap = textureLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg',
            () => updateProgress(50, '法线贴图加载完成'));
        const earthSpecularMap = textureLoader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg',
            () => updateProgress(75, '高光贴图加载完成'));
        
        earthMaterial = new THREE.MeshPhongMaterial({
            map: earthTexture,
            bumpMap: earthBumpMap,
            bumpScale: 0.05,
            specularMap: earthSpecularMap,
            specular: new THREE.Color(0x333333),
            shininess: 5
        });
        
        earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
        earthMesh.receiveShadow = true;
        earthMesh.castShadow = true;
        earthGroup.add(earthMesh);
        
        // 创建云层
        const cloudGeometry = new THREE.SphereGeometry(1.005, 64, 64);
        const cloudMaterial = new THREE.MeshPhongMaterial({
            map: textureLoader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png'),
            transparent: true,
            opacity: 0.7
        });
        
        const cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
        cloudMesh.receiveShadow = true;
        earthGroup.add(cloudMesh);
        
        // 创建大气层效果
        const atmosphereGeometry = new THREE.SphereGeometry(1.02, 64, 64);
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: {
                "c":   { value: 1.0 },
                "p":   { value: 6.0 }
            },
            vertexShader: `
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float c;
                uniform float p;
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(c - dot(vNormal, vec3(0.0, 0.0, 1.0)), p);
                    gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                }
            `,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        
        const atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        earthGroup.add(atmosphereMesh);
        
        // 添加星空背景
        const starGroup = new THREE.Group();
        scene.add(starGroup);
        
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.2,
            transparent: true,
            opacity: 0.8
        });
        
        const starVertices = [];
        for (let i = 0; i < 10000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            // 确保星星在地球外围
            const length = Math.sqrt(x*x + y*y + z*z);
            if(length > 5) {
                starVertices.push(x, y, z);
            }
        }
        
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const stars = new THREE.Points(starGeometry, starMaterial);
        starGroup.add(stars);
        
        // 添加卫星轨道和卫星
        const satellites = [];
        for (let i = 0; i < 5; i++) {
            const orbitRadius = 1.5 + Math.random() * 0.5;
            const orbitHeight = (Math.random() - 0.5) * 0.5;
            const satelliteGeometry = new THREE.SphereGeometry(0.02, 16, 16);
            const satelliteMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            const satellite = new THREE.Mesh(satelliteGeometry, satelliteMaterial);
            
            // 随机初始位置
            const angle = Math.random() * Math.PI * 2;
            satellite.position.x = Math.cos(angle) * orbitRadius;
            satellite.position.z = Math.sin(angle) * orbitRadius;
            satellite.position.y = orbitHeight;
            
            // 存储卫星信息用于动画
            satellites.push({
                mesh: satellite,
                radius: orbitRadius,
                height: orbitHeight,
                speed: 0.01 + Math.random() * 0.02,
                angle: angle
            });
            
            earthGroup.add(satellite);
        }
        
        // 添加轨道环
        for (let i = 0; i < 3; i++) {
            const orbitRadius = 1.5 + i * 0.2;
            const orbitGeometry = new THREE.RingGeometry(orbitRadius - 0.01, orbitRadius + 0.01, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4488FF, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.3
            });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = Math.random() * Math.PI;
            earthGroup.add(orbit);
        }
        
        // 添加轨道控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 10;
        
        // 处理窗口大小变化
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 控制元素
        const rotationSpeedControl = document.getElementById('rotationSpeed');
        const cloudSpeedControl = document.getElementById('cloudSpeed');
        const lightIntensityControl = document.getElementById('lightIntensity');
        const currentTimeDisplay = document.getElementById('currentTime');
        
        // 更新进度
        let loadedItems = 0;
        function updateProgress(percent, msg) {
            loadedItems++;
            document.getElementById('progress').textContent = `${percent}%`;
            if(loadedItems >= 3) {
                setTimeout(() => {
                    document.getElementById('loading').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 500);
                }, 500);
            }
        }
        
        // 实时时钟
        const clock = new THREE.Clock();
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            // 获取当前时间并更新显示
            const now = new Date();
            currentTimeDisplay.textContent = now.toLocaleTimeString();
            
            // 从控制滑块获取值
            const rotationSpeed = parseFloat(rotationSpeedControl.value);
            const cloudSpeed = parseFloat(cloudSpeedControl.value);
            const lightIntensity = parseFloat(lightIntensityControl.value);
            
            // 更新光照强度
            sunLight.intensity = lightIntensity;
            
            // 旋转地球（自转）
            earthGroup.rotation.y += rotationSpeed;
            
            // 旋转云层
            cloudMesh.rotation.y += cloudSpeed;
            
            // 动画卫星
            satellites.forEach(satellite => {
                satellite.angle += satellite.speed * delta * 10;
                satellite.mesh.position.x = Math.cos(satellite.angle) * satellite.radius;
                satellite.mesh.position.z = Math.sin(satellite.angle) * satellite.radius;
                satellite.mesh.position.y = satellite.height;
                
                // 让卫星稍微面向运动方向
                satellite.mesh.lookAt(0, satellite.height, 0);
            });
            
            // 轻微摆动星光以增加动态感
            stars.rotation.y += 0.0001;
            
            // 更新控制器
            controls.update();
            
            // 渲染场景
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>